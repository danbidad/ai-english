import { ArgumentParser } from 'argparse';
import { YouTubeTranscriptApi } from './api.js';
import { FormatterLoader } from './formatters.js';

interface ParsedArgs {
  list_transcripts: boolean;
  video_ids: string[];
  languages: string[];
  exclude_generated: boolean;
  exclude_manually_created: boolean;
  format: string;
  translate: string;
  http_proxy: string;
  https_proxy: string;
  cookies: string | null;
}

export class YouTubeTranscriptCli {
  private _args: string[];

  constructor(args: string[]) {
    this._args = args;
  }

  run(): string {
    const parsedArgs = this._parseArgs();

    if (parsedArgs.exclude_manually_created && parsedArgs.exclude_generated) {
      return "";
    }

    let proxies: Record<string, string> | null = null;
    if (parsedArgs.http_proxy !== "" || parsedArgs.https_proxy !== "") {
      proxies = {
        http: parsedArgs.http_proxy,
        https: parsedArgs.https_proxy
      };
    }

    const cookies = parsedArgs.cookies;

    const transcripts: any[] = [];
    const exceptions: Error[] = [];

    for (const videoId of parsedArgs.video_ids) {
      try {
        transcripts.push(
          this._fetchTranscript(parsedArgs, proxies, cookies, videoId)
        );
      } catch (exception) {
        exceptions.push(exception as Error);
      }
    }

    const exceptionMessages = exceptions.map(exception => exception.toString());
    const transcriptOutput = transcripts.length > 0
      ? [new FormatterLoader().load(parsedArgs.format).formatTranscripts(transcripts)]
      : [];

    return [...exceptionMessages, ...transcriptOutput].join("\n\n");
  }

  private async _fetchTranscript(
    parsedArgs: ParsedArgs,
    proxies: Record<string, string> | null,
    cookies: string | null,
    videoId: string
  ) {
    const transcriptList = await YouTubeTranscriptApi.listTranscripts(
      videoId,
      proxies ?? undefined,
      cookies
    );

    if (parsedArgs.list_transcripts) {
      return transcriptList.toString();
    }

    let transcript;
    if (parsedArgs.exclude_manually_created) {
      transcript = transcriptList.findGeneratedTranscript(
        parsedArgs.languages
      );
    } else if (parsedArgs.exclude_generated) {
      transcript = transcriptList.findManuallyCreatedTranscript(
        parsedArgs.languages
      );
    } else {
      transcript = transcriptList.findTranscript(parsedArgs.languages);
    }

    if (parsedArgs.translate) {
      transcript = transcript.translate(parsedArgs.translate);
    }

    return transcript.fetch();
  }

  private _parseArgs(): ParsedArgs {
    const parser = new ArgumentParser({
      description:
        "This is a TypeScript API which allows you to get the transcripts/subtitles for a given YouTube video. " +
        "It also works for automatically generated subtitles and it does not require a headless browser, like " +
        "other selenium based solutions do!"
    });

    parser.add_argument("--list-transcripts", {
      action: "storeTrue",
      help: "This will list the languages in which the given videos are available in."
    });

    parser.add_argument("video_ids", {
      nargs: "+",
      help: "List of YouTube video IDs."
    });

    parser.add_argument("--languages", {
      nargs: "*",
      default: ["en"],
      help:
        "A list of language codes in a descending priority. For example, if this is set to \"de en\" it will " +
        "first try to fetch the german transcript (de) and then fetch the english transcript (en) if it fails " +
        "to do so. As I can't provide a complete list of all working language codes with full certainty, you " +
        "may have to play around with the language codes a bit, to find the one which is working for you!"
    });

    parser.add_argument("--exclude-generated", {
      action: "storeTrue",
      help: "If this flag is set transcripts which have been generated by YouTube will not be retrieved."
    });

    parser.add_argument("--exclude-manually-created", {
      action: "storeTrue",
      help: "If this flag is set transcripts which have been manually created will not be retrieved."
    });

    parser.add_argument("--format", {
      default: "pretty",
      choices: Object.keys(FormatterLoader.TYPES),
      help: "Format of the transcript output."
    });

    parser.add_argument("--translate", {
      default: "",
      help:
        "The language code for the language you want this transcript to be translated to. Use the " +
        "--list-transcripts feature to find out which languages are translatable and which translation " +
        "languages are available."
    });

    parser.add_argument("--http-proxy", {
      default: "",
      metavar: "URL",
      help: "Use the specified HTTP proxy."
    });

    parser.add_argument("--https-proxy", {
      default: "",
      metavar: "URL",
      help: "Use the specified HTTPS proxy."
    });

    parser.add_argument("--cookies", {
      default: null,
      help: "The cookie file that will be used for authorization with youtube."
    });

    const args = parser.parse_args(this._args);
    return this._sanitizeVideoIds(args);
  }

  private _sanitizeVideoIds(args: ParsedArgs): ParsedArgs {
    args.video_ids = args.video_ids.map(videoId => videoId.replace(/\\/g, ""));
    return args;
  }
}
