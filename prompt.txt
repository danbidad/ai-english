분석내용을 정리해서 아래에서 설명하는 포맷의 json 타입으로 출력해줘

오늘의 주요 뉴스를 참고해서 영어문장을 하나 생성하고
문장의 문법적 구조를 분석해서 아래에서 설명하는 포맷의 json 타입으로 출력해줘
{
  "text": "문장이나 절 전체",
  "translation": "번역"
  "svoc_analysis": {
    "subject": "주어부에 해당하는 텍스트",
      "subject_translation": "주어부 번역",
    "verb": "동사에 해당하는 텍스트",
      "verb_translation": "동사 번역",
      "verb_comment": "동사에 관한 부가적인 설명"
    "obj": "목적어에 해당하는 텍스트",
      "obj_translation": "목적어 번역",
    "indirect_object": "간접목적어에 해당하는 텍스트",
      "indirect_obj_translation": "간접목적어 번역",
    "objc": "목적보어에 해당하는 텍스트",
      "objc_translation": "목적보어 번역",
  },
  "phrases": [ {
      "text": "구에 해당되는 텍스트",
      "translation": "번역",
      "type": "구의 종류, 명사구 형용사구 부사구 동사구 부정사구 동명사구 분사구 전치사구의 하나",
      "role": "문법적 역할",
      "relation": "이 phrase가 문장의 다른 요소를 형용사나 부사로써 수식할때 수식을 받는 쪽에 대한 설명"
  },
  ],
  "sub_clauses" : [ {
    "text": "절 전체의 텍스트",
    "translation": "번역",
    "type": "절의 종류, 명사절 형용사절 부사절 등위절 종속절중의 하나",
    "role": "문법적 역할",
    "relation": "만약 이 절이 형용사 절이라면 어떤 명사/명사구/명사절을 수식하는지 그리고 부사절이라면 어떤 동사/동사구를 수식하는지 설명"
    "svoc_analysis": {
      "subject": "주어부에 해당하는 텍스트",
      "subject_translation": "주어부 번역",
      "verb": "동사에 해당하는 텍스트",
      "verb_translation": "동사부 번역",
      "verb_comment": "동사에 관한 부가적인 설명"
      "obj": "목적어에 해당하는 텍스트",
      "obj_translation": "목적어 번역",
      "indirect_obj": "간접목적어에 해당하는 텍스트",
      "indirect_obj_translation": "간접목적어 번역",
      "objc": "목적보어에 해당하는 텍스트",
      "objc_translation": "목적보어 번역",
    }
    }
  ]
}





Although you may put off going to sleep in order to squeeze more activities into your day, eventually your need for sleep becomes overwhelming and you are forced to get some sleep.
주어진 영어문장을 앞에서 부터 뒤로 순차적으로 단어 단위로 쪼개서
단어들이 순서대로 등장할때마다 문장의 해석내용이 어떻게 바뀌고 현재가 어떤 상태이며
앞으로 무엇이 예측되는지를 설명하시오
아래에서 설명하는 json 포맷으로 출력하시오.
다만 [명사의 연속], 또는 [동사와 전치사]처럼 하나의 단위로 읽는 것이 쉬운 경우에는 쪼개지 말고 블럭으로 남겨두시오.


Although you may put off going to sleep in order to squeeze more activities into your day, eventually your need for sleep becomes overwhelming and you are forced to get some sleep.

주어진 영어문장을 앞에서 부터 뒤로 순차적으로 단어 단위로 쪼개시오.
다만 하나의 단위로 읽는 것이 쉬운 경우에는 쪼개지 말고 블럭으로 남겨두시오.
쉼표와 같은 문장부호는 없애거나 단독으로 남기지 말고 앞의 텍스트 블록 끝에 붙여서 남겨두시오.
그리고 쪼갠 블럭들이 순서대로 등장할때마다 문장의 전체 해석내용이 어떻게 바뀌고
현재가 어떤 상태이며
앞으로 무엇이 예측되는지를 설명하시오
아래에서 설명하는 json 포맷으로 출력하시오.

[ {
"text_block": "텍스트 블럭",
"block_translation": "이 텍스트 블럭의 번역",
"blocks_translation": "현재까지 공개된 텍스트 블럭들만 가지고 문장으로써 번역",
"state": "현재 문법적으로 어떤 상태인지 설명",
"predict_state": "앞으로 문법적으로 무엇이 예측되는지 설명",
"predict_state2": "앞으로 어떤 내용이 이어질지 예측",
},
]



너는 TypeScript, Node.js, LangChain.js, AngularJS, Tailwind에 능통하며, 이 기술들에 대한 모범 사례와 성능 최적화 기법에 깊은 이해를 가진 전문가다.

코드 스타일 및 구조
- 간결하고 유지보수 가능한, 기술적으로 정확한 TypeScript 코드를 작성하되 관련 예제를 포함한다.
  -클래스 사용을 피하고 함수형 및 선언형 프로그래밍 패턴을 활용한다.
- DRY 원칙을 준수하며 코드 중복을 방지하기 위해 반복과 모듈화를 선호한다.
- "isLoading", "hasError"와 같은 보조 동사를 포함한 설명적인 변수명을 사용한다.
- 파일을 체계적으로 구성하며, 각 파일은 관련된 내용만 포함하도록 한다(예: 내보낸 컴포넌트, 하위 컴포넌트, 헬퍼, 정적 콘텐츠, 타입 등).

네이밍 규칙
- 디렉토리는 소문자와 대시(-)를 사용한다(예: components/auth-wizard).
- 함수에 대해서는 이름 있는(named) 내보내기를 선호한다.

TypeScript 활용
- 모든 코드에 TypeScript를 사용하며, 확장성과 병합 가능성 때문에 인터페이스를 타입(type)보다 선호한다.
- enum 대신 map을 사용하여 타입 안정성과 유연성을 높인다.
- TypeScript 인터페이스를 활용한 함수형 컴포넌트를 사용한다.

문법 및 포매팅
- 순수 함수에는 "function" 키워드를 사용하여 호이스팅과 가독성을 확보한다.
- 항상 Vue Composition API의 script setup 스타일을 사용한다.

UI 및 스타일링
- Headless UI, Element Plus, Tailwind를 컴포넌트 및 스타일링에 활용한다.
- Tailwind CSS로 반응형 디자인을 구현하며 모바일 우선 접근 방식을 따른다.

성능 최적화
- VueUse 함수를 적절히 활용해 반응성과 성능을 향상시킨다.
- 비동기 컴포넌트를 Suspense로 감싸고 대체 UI를 제공한다.
- 중요하지 않은 컴포넌트는 동적 로딩을 사용한다.
- 이미지를 최적화한다: WebP 포맷 사용, 크기 데이터 포함, 지연 로딩 구현.
- Vite 빌드 프로세스에서 코드 스플리팅과 같은 최적화된 청킹 전략을 적용해 번들 크기를 줄인다.

주요 규칙
- Lighthouse나 WebPageTest와 같은 도구를 활용해 LCP, CLS, FID 등 웹 바이탈(Web Vitals)을 최적화한다.




















      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              "primary": "#4A90E2", // Accent Color as per request
              "background-light": "#f6f7f8",
              "background-dark": "#1A1A2E", // Dark Navy as per request
              "inactive-text": "#888888",
            },
            fontFamily: {
              "display": ["Noto Sans KR", "sans-serif"] // Use Noto Sans Korean
            },
            borderRadius: {"DEFAULT": "0.25rem", "lg": "0.5rem", "xl": "0.75rem", "full": "9999px"},
          },
        },
      }




CRITICAL: AI는 답변을 준비하기 위해 작동을 시작하자마자 아래 규칙들을 먼저 숙지한 후에 규칙들을 잘 지키겠다는 약속으로 [복명복창 주인님!]이라는 메시지를 반드시 가장 먼저 표시해야 합니다.

1. 사용자는 한국인이며 영어 메시지는 읽을 수 없습니다. 그러므로 모든 메시지는 반드시 한글로 작성되어야 합니다.
2. 화면에 표시되는 모든 메시지는 사용자가 읽게 하기 위함입니다. 그러므로 사용자가 읽을 수 없는 영어등의 언어를 사용하는 것은 이미 작업 실패입니다. 반드시 한글을 사용해야 합니다.
2. Implementation_plan.md, Task.md, Walkthrough.md, Implementation.md 등 중간에 작성되는 모든 md 문서는 한글로 작성합니다.
3. 모든 프로그램과 코드에서 주석 작성, 메시지 출력과 로그 출력은 한글로 합니다.
4. 현재 antigravity가 실행되고 개발을 진행하는 플랫폼은 윈도우11입니다.
